\hsection{Introduction}%
\label{sec:structure:intro}%
%
From the examples that we have seen, we know that optimization problems come in all kinds of different shapes and forms.
Without practice, it is not directly clear how to identify, define, understand, or solve them.
Moreover, it is not really clear how we can solve such a wide range of problems using the same kind of methods.

The goal of this part of the book is to bring some order into this mess.
We will approach an optimization task step-by-step by formalizing its components, which will then allow us to apply efficient algorithms to it.
This \emph{structure of optimization} is a blueprint that can be used in many different scenarios as basis to apply different optimization algorithms.

We will approach this domain from the perspective of a programmer.
Imagine you are a programmer and your job would be to, well, make a program that solves optimization problems.
Now, an \inQuotes{optimization problem} seems to be a very general and amorphous thing.
The first thing you would try to do is to discover some components that commonly occur in all of the optimization problems you can think of.
If you can manage to specify how such components look like, what information and functionality they provide, then you are a step closer to fulfilling your task.
Then, you can develop algorithms that use these information and functionality to find solutions.
This is what we will do.

First, let us clarify what \emph{optimization problems} actually are.%
%
\begin{definition}[Optimization Problem~\textrm{I}]%
\label{def:optimizationProblemEconomical}%
An \emph{optimization problem} is a situation~\instance\ which requires deciding for one choice from a set of possible alternatives in order to reach a predefined/required goal at minimal costs.%
\end{definition}%
%
\cref{def:optimizationProblemEconomical} presents an economical point of view on optimization in a rather informal manner.
But the points come across:
We want to reach a certain goal, e.g., visit all cities in a \pgls{optTSP}, process all jobs in a \pgls{optJSSP}, pack all the items into bins in a \pgls{optBPP}, or assign all factories to locations in the \pgls{optQAP}.
We have several possible ways to reach that goal and we need to choose one among them.
Each of these possible choices has an associated cost.
Since all of them lead to reaching the goal, we want to pick the one choice with the minimal costs.
We can refine this situation into the more mathematical formulation given in \cref{def:optimizationProblemMathematical}.%
%
\begin{definition}[Optimization Problem~\textrm{II}]%
\label{def:optimizationProblemMathematical}%
The goal of solving an \emph{optimization problem} is finding an input~$\solution\in\solutionSpace$ for which a function~$\objFun:\solutionSpace\mapsto\realNumbers$ takes on a value as small as possible.%
\end{definition}%
%
From these definitions, we can already deduce a three necessary components that make up such an optimization problem.
We will look at them from the perspective of a programmer:%
%
\begin{enumerate}%
%
\item The first obvious component is a data structure~\solutionSpace\ representing possible solutions to the problem.
This one half of the output of the optimization software.%
%
\item Then, there is the so-called objective function~$\objFun:\solutionSpace\mapsto\realNumbers$, which rates the quality of the candidate solutions~$\solution\in\solutionSpace$.
It basically returns the cost of a solution and we usually want to minimize it.%
%
\item Finally, there must be some way to instantiate the data structure~\solutionSpace, i.e., to sample one~\solution\ from~\solutionSpace.%
%
\end{enumerate}%
%
\endhsection%
%
